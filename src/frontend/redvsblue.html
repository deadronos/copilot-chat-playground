<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Space Battle Sim</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            color: white;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .top-bar {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            display: flex;
            justify-content: center;
            gap: 40px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px black;
        }
        .red-text { color: #ff4d4d; }
        .blue-text { color: #4d4dff; }

        .controls {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 15px;
            border-top: 1px solid #333;
        }
        button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            transition: 0.2s;
        }
        button:hover { background: #555; }
        button:active { transform: translateY(1px); }
        .btn-red { border-bottom: 3px solid #ff4d4d; }
        .btn-blue { border-bottom: 3px solid #4d4dff; }
        .btn-reset { border-bottom: 3px solid white; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="top-bar">
        <div class="red-text">RED SHIPS: <span id="red-count">0</span></div>
        <div class="blue-text">BLUE SHIPS: <span id="blue-count">0</span></div>
    </div>
    
    <div class="controls">
        <button class="btn-red" onclick="spawnShip('red')">+1 RED</button>
        <button class="btn-blue" onclick="spawnShip('blue')">+1 BLUE</button>
        <button class="btn-reset" onclick="resetSimulation()">RESET</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const redCountDisplay = document.getElementById('red-count');
    const blueCountDisplay = document.getElementById('blue-count');

    // Game State
    let width, height;
    let ships = [];
    let bullets = [];
    let particles = [];
    let stars = [];

    // Configuration
    const FRICTION = 0.98;
    const SHIP_THRUST = 0.2;
    const TURN_SPEED = 0.08;
    const BULLET_SPEED = 8;
    const BULLET_LIFE = 50;
    const FIRE_RATE = 20; 
    const AI_VISION_DIST = 800; // How far they can see

    // Setup Canvas
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- CLASSES ---

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 5;
            this.vy = (Math.random() - 0.5) * 5;
            this.life = 1.0;
            this.color = color;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.03;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class Bullet {
        constructor(x, y, angle, team) {
            this.x = x;
            this.y = y;
            this.vx = Math.cos(angle) * BULLET_SPEED;
            this.vy = Math.sin(angle) * BULLET_SPEED;
            this.life = BULLET_LIFE;
            this.team = team;
            this.color = (team === 'red') ? '#ffcccc' : '#ccccff';
            this.radius = 3;
            this.active = true;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;

            // Screen Wrapping
            if (this.x < 0) this.x = width;
            if (this.x > width) this.x = 0;
            if (this.y < 0) this.y = height;
            if (this.y > height) this.y = 0;

            if (this.life <= 0) this.active = false;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class Ship {
        constructor(x, y, team) {
            this.x = x;
            this.y = y;
            this.team = team;
            this.vx = Math.random() - 0.5;
            this.vy = Math.random() - 0.5;
            this.angle = Math.random() * Math.PI * 2;
            
            this.color = (team === 'red') ? '#ff4d4d' : '#4d4dff';
            this.health = 30; // Lower health for faster gameplay
            this.cooldown = Math.random() * 20;
            this.radius = 12;
        }

        getNearestEnemy() {
            let nearest = null;
            let minDist = Infinity;

            ships.forEach(other => {
                if (other.team !== this.team) {
                    // Calculate distance accounting for screen wrap
                    let dx = Math.abs(this.x - other.x);
                    let dy = Math.abs(this.y - other.y);
                    
                    if (dx > width / 2) dx = width - dx;
                    if (dy > height / 2) dy = height - dy;
                    
                    let dist = Math.hypot(dx, dy);

                    if (dist < minDist && dist < AI_VISION_DIST) {
                        minDist = dist;
                        nearest = other;
                    }
                }
            });
            return { enemy: nearest, dist: minDist };
        }

        updateAI() {
            const { enemy, dist } = this.getNearestEnemy();

            if (enemy) {
                // Calculate vector to enemy accounting for screen wrap
                let dx = enemy.x - this.x;
                let dy = enemy.y - this.y;

                // If the enemy is closer via the screen edge, aim "through" the wall
                if (dx > width/2) dx -= width;
                if (dx < -width/2) dx += width;
                if (dy > height/2) dy -= height;
                if (dy < -height/2) dy += height;

                const targetAngle = Math.atan2(dy, dx);
                let diff = targetAngle - this.angle;

                // Normalize angle difference (-PI to PI)
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                // Turn towards enemy
                if (diff > 0.05) this.angle += TURN_SPEED;
                else if (diff < -0.05) this.angle -= TURN_SPEED;

                // Thrust if roughly facing target
                if (Math.abs(diff) < 1.0) {
                    this.vx += Math.cos(this.angle) * SHIP_THRUST;
                    this.vy += Math.sin(this.angle) * SHIP_THRUST;

                    // Engine particles
                    if (Math.random() > 0.5) {
                        let px = this.x - Math.cos(this.angle) * 15;
                        let py = this.y - Math.sin(this.angle) * 15;
                        particles.push(new Particle(px, py, 'orange'));
                    }
                }

                // Shoot if aligned and close enough
                if (Math.abs(diff) < 0.2 && this.cooldown <= 0 && dist < 400) {
                    this.shoot();
                }
            } else {
                // No enemies? Just drift and rotate slowly
                this.angle += 0.01;
                this.vx *= 0.95;
                this.vy *= 0.95;
            }
        }

        update() {
            this.updateAI();

            // Physics
            this.vx *= FRICTION;
            this.vy *= FRICTION;
            this.x += this.vx;
            this.y += this.vy;

            // Screen Wrapping
            if (this.x < 0) this.x = width;
            if (this.x > width) this.x = 0;
            if (this.y < 0) this.y = height;
            if (this.y > height) this.y = 0;

            // Cooldown
            if (this.cooldown > 0) this.cooldown--;
        }

        shoot() {
            const bx = this.x + Math.cos(this.angle) * 15;
            const by = this.y + Math.sin(this.angle) * 15;
            bullets.push(new Bullet(bx, by, this.angle, this.team));
            this.cooldown = FIRE_RATE + Math.random() * 10;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);

            // Draw Ship Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, -10);
            ctx.closePath();
            ctx.fill();
            
            // Team Indicator (Ring)
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI*2);
            ctx.stroke();
            
            ctx.restore();
        }
    }

    // --- GAME LOGIC ---

    function initStars() {
        stars = [];
        for(let i=0; i<150; i++) {
            stars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 1.5,
                alpha: Math.random()
            });
        }
    }

    function spawnShip(team) {
        let x, y;
        // Spawn Red on Left, Blue on Right to prevent instant collisions
        if (team === 'red') {
            x = Math.random() * (width * 0.3);
        } else {
            x = width - (Math.random() * (width * 0.3));
        }
        y = Math.random() * height;
        ships.push(new Ship(x, y, team));
        updateCounts();
    }

    function resetSimulation() {
        ships = [];
        bullets = [];
        particles = [];
        
        // Initial Setup: 2 vs 2
        spawnShip('red'); spawnShip('red');
        spawnShip('blue'); spawnShip('blue');
        
        updateCounts();
    }

    function updateCounts() {
        const redCount = ships.filter(s => s.team === 'red').length;
        const blueCount = ships.filter(s => s.team === 'blue').length;
        redCountDisplay.innerText = redCount;
        blueCountDisplay.innerText = blueCount;
    }

    function checkCollisions() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            if (!b.active) continue;

            for (let j = ships.length - 1; j >= 0; j--) {
                let s = ships[j];
                
                // Don't hit teammates
                if (b.team === s.team) continue;

                // Simple Circle Collision
                const dist = Math.hypot(b.x - s.x, b.y - s.y);
                if (dist < s.radius + b.radius) {
                    // Hit!
                    s.health -= 10;
                    b.active = false;
                    
                    // Particles
                    for(let k=0; k<5; k++) {
                        particles.push(new Particle(b.x, b.y, s.color));
                    }

                    // Ship Death
                    if (s.health <= 0) {
                        // Explosion
                        for(let k=0; k<15; k++) {
                            particles.push(new Particle(s.x, s.y, 'white'));
                            particles.push(new Particle(s.x, s.y, s.color));
                        }
                        ships.splice(j, 1);
                        updateCounts();
                    }
                    break; // Bullet hits one target only
                }
            }
        }
    }

    function drawBackground() {
        ctx.fillStyle = "#050510";
        ctx.fillRect(0, 0, width, height);
        
        ctx.fillStyle = "white";
        stars.forEach(star => {
            ctx.globalAlpha = star.alpha;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1.0;
    }

    function loop() {
        drawBackground();

        // Ships
        ships.forEach(s => {
            s.update();
            s.draw();
        });

        // Bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.update();
            b.draw();
            if (!b.active) bullets.splice(i, 1);
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.update();
            p.draw();
            if (p.life <= 0) particles.splice(i, 1);
        }

        checkCollisions();
        requestAnimationFrame(loop);
    }

    // Start
    initStars();
    resetSimulation();
    loop();

</script>
</body>
</html>